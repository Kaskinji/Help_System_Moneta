import sys

sys.path.append(str('/Users/ilya/Documents/GitHub/Help_System_Moneta'))


import os
import json
from Ontologies.Comcore_E_Ontology import comcore_E_ontology
from Ontologies.Comcore_R_Ontology import comcore_R_ontology
import time
import re
import requests


def llm_request(prompt: str, api_key: str) -> str:
  try:
    response = requests.post(
        url="https://openrouter.ai/api/v1/chat/completions",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json",
        },
        data=json.dumps({
            "model": "deepseek/deepseek-r1-0528:free",
            "messages": [{"role": "user", "content": prompt}],
        })
    )

    if response.status_code == 200:
        return response.json()['choices'][0]['message']['content']
    else:
        return f"Ошибка {response.status_code}: {response.text}"

  except Exception as e:
    return f"Ошибка при запросе: {str(e)}"
  

def extract_entities_from_chunk2(chunk_content):
    prompt = f'''
    ТЕХНИЧЕСКОЕ ЗАДАНИЕ:
    Извлеки из предоставленного текста ВСЕ сущности и отношения, СТРОГО СООТВЕТСТВУЮЩИЕ ОНТОЛОГИИ СУЩНОСТЕЙ И ОТНОШЕНИЙ.
    Формат вывода ТОЛЬКО Turtle (ttl) без каких-либо пояснений или комментариев.

    ЖЕСТКИЕ ТРЕБОВАНИЯ:
    1. Извлечение:
    - ТОЛЬКО сущности и отношения, СТРОГО соответствующие классам и свойствам онтологии
    - НИКАКИХ посторонних элементов или интерпретаций
    - Если сущность не соответствует онтологии - НЕ включать её
    - идентификаторы извлеченных сущностей формируются по правилу ":label", где label - это словоформа, описывающая сущность (метка или имя сущности); при этом, если словоформа длиннее, чем 40 символов, то она обрезается на 40-м символе; если словоформа состоит из нескольких слов, то она формируется как одно слово, в котором вместо пробела подставляется нижнее подчеркивание (например ":оператор_отдела"); если такой идентификатор уже существует, то либо это та же сущность и надо только добавить новые ее атрибуты или связи или, если это другая похожая по начальному имени сущность, то сформировать идентификатор с добавлением в конце инкрементируемого номера (":оператор_отдела_02")
    - идентификатор_предиката берется из файла описывающего онтологию в соответствии с форматом ont_name:predicate_name;
    - 1. Извлечение:
    - ТОЛЬКО сущности и отношения, явно соответствующие классам и свойствам онтологии
    - НИКАКИХ посторонних элементов или интерпретаций
    - Если сущность не соответствует онтологии - НЕ включать её
    - идентификаторы извлеченных сущностей формируются по правилу ":label", где label - это словоформа, описывающая сущность (метка или имя сущности); при этом, если словоформа длиннее, чем 40 символов, то она обрезается на 40-м символе; если словоформа состоит из нескольких слов, то она формируется как одно слово, в котором вместо пробела подставляется нижнее подчеркивание (например ":оператор_отдела"); если такой идентификатор уже существует, то либо это та же сущность и надо только добавить новые ее атрибуты или связи или, если это другая похожая по начальному имени сущность, то сформировать идентификатор с добавлением в конце инкрементируемого номера (":оператор_отдела_02")
    - идентификатор_предиката берется из файла описывающего онтологию в соответствии с форматом ont_name:predicate_name;
    - должна быть гарантия, что каждая сущность 
    - Для КАЖДОЙ сущности добавьте связь с чанком через предикат comcore:mentionedIn
    Пример:
     :регистрация comcore:mentionedIn : 42 .
     id текущего чанка: 0 - всегда

    2. Формат идентификаторов:
    - :lowercase_with_underscores
    - Максимум 40 символов

    3. (ОБЯЗАТЕЛЬНО) Для каждой сущности минимум три триплета: тип, метка и связь:
    (идентификатор_сущности, rdf:type, ont_name:class_name);
    (идентификатор_сущности, rdfs:label, "имя сущности");
    (идентификатор_сущности, идентификатор_предиката, идентификатор_сущности_2);

    4. ЗАПРЕЩЕНО:
    - в ответе выдавать блок <think>
    - Добавлять комментарии
    - Изменять формат вывода
    - Изобретать несуществующие в онтологии свойства

    5. Для каждой сущности формата "Термин - определение" к триплету добавить свойство dc:definition. Предыдущие поля с отношениями должны быть указаны обязательно независимо от того фигурируют они или нет в definition.
    Пример:
    :авторизационные_данные rdf:type comcore:Resource ;
    rdfs:label "Авторизационные данные"@ru ;
    comcore:isResourceOf :вход_в_личный_кабинет ;
    dc:definition "Авторизационные данные - адрес электронной почты, представляемый НКО Получателем при регистрации в Системе МОНЕТА.РУ для входа в Личный кабинет в Системе МОНЕТА.РУ." .


    ТЕКСТ: 
{chunk_content}
    ОНТОЛОГИЯ: 
{comcore_E_ontology}
    ОТНОШЕНИЯ: 
{comcore_R_ontology}

    Пример КОРРЕКТНОГО вывода:
    ```
    :тариф rdf:type comcore:Resource ;
    rdfs:label "Тариф"@ru ;
    comcore:isResourceOf :упрощенная_идентификация ;
    comcore:canBeResourceFor :начисление_вознаграждения ;
    dc:description """
    Тариф - определение...""".
    :торговая_площадка rdf:type comcore:Agent ;
    rdfs:label "Торговая площадка"@ru ;
    comcore:isActorOf :обеспечение_взаимодействия ;
    comcore:isResponsibleFor :программно-аппаратный_комплекс ;
    dc:description """
    Торговая площадка - определение...""".

    :упрощенная_идентификация rdf:type comcore:Process ;
    rdfs:label "Упрощенная идентификация"@ru ;
    comcore:hasResult :статус_неидентифицированного_клиента ;
    comcore:isPartOf :процедура_проверки_клиента ;
    dc:description """
    Упрощенная идентификация - определение...""".
    '''

    return llm_request(prompt, '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')
